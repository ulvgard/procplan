<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ProcPlan Scheduler</title>
  <style>
    :root {
      font-family: Arial, sans-serif;
      color: #0f172a;
    }
    body {
      margin: 0;
      padding: 0;
      background: #e9eef6;
    }
    header {
      background: #264653;
      color: #fff;
      padding: 0.6rem 2rem;
    }
    header .header-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }
    header .header-text h1 {
      margin: 0;
      font-size: 1.6rem;
      letter-spacing: 0.02em;
    }
    header .header-text p {
      margin: 0.2rem 0 0;
      font-size: 0.95rem;
      opacity: 0.85;
    }
    header h1 {
      margin: 0;
      font-size: 1.6rem;
      letter-spacing: 0.02em;
    }
    header p {
      margin: 0.2rem 0 0;
      font-size: 0.95rem;
      opacity: 0.85;
    }
    header #help-button {
      width: auto;
      padding: 0.4rem 0.75rem;
      font-size: 0.9rem;
      white-space: nowrap;
      background: rgba(255, 255, 255, 0.18);
      border: 1px solid rgba(255, 255, 255, 0.35);
      color: #fff;
    }
    header #help-button:hover {
      background: rgba(255, 255, 255, 0.28);
    }
    main {
      padding: 0 4vw 1.25rem;
      margin: 0;
      width: 100%;
      box-sizing: border-box;
    }
    main > section:first-child {
      margin-top: 0;
    }
    section {
      background: #fff;
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      border: 1px solid #cbd5e1;
      box-shadow: 0 4px 14px rgba(15, 23, 42, 0.12);
    }
    #controls {
      padding: 1rem;
    }
    #controls h2 {
      margin-bottom: 0.75rem;
    }
    #controls .form-row {
      gap: 0.75rem;
      margin-bottom: 0.75rem;
    }
    #controls label {
      margin-bottom: 0.2rem;
      font-size: 0.9rem;
    }
    #controls input,
    #controls select,
    #controls button {
      font-size: 0.95rem;
      padding: 0.45rem;
    }
    #availability-section {
      overflow-x: auto;
    }
    #booking-panel {
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid #e2e8f0;
    }
    #manage-booking-panel {
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid #e2e8f0;
    }
    #manage-booking-summary {
      margin: 0 0 1rem;
      font-size: 0.95rem;
      color: #334155;
    }
    #manage-booking-list {
      list-style: none;
      padding: 0;
      margin: 0 0 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .manage-booking-item {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 0.75rem;
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      padding: 0.75rem;
    }
    .manage-booking-details {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      font-size: 0.9rem;
    }
    .manage-booking-heading {
      font-weight: 600;
      color: #1f2937;
    }
    .manage-booking-item button {
      width: auto;
      flex-shrink: 0;
      padding: 0.4rem 0.75rem;
    }
    #status-panel {
      position: fixed;
      top: 1.5rem;
      right: 1.5rem;
      width: min(320px, 90vw);
      padding: 0;
      background: transparent;
      box-shadow: none;
      margin: 0;
      z-index: 20;
      pointer-events: none;
    }
    #status-panel .status {
      pointer-events: auto;
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.2);
    }
    h1, h2 {
      margin-top: 0;
    }
    label {
      display: block;
      margin-bottom: 0.25rem;
      font-weight: bold;
    }
    input, select, button, textarea {
      font-size: 1rem;
      padding: 0.5rem;
      border: 1px solid #94a3b8;
      border-radius: 4px;
      width: 100%;
      box-sizing: border-box;
    }
    input:focus, select:focus, textarea:focus, button:focus {
      outline: 2px solid rgba(37, 99, 235, 0.55);
      outline-offset: 2px;
    }
    details.dropdown {
      position: relative;
    }
    details.dropdown > summary {
      list-style: none;
      border: 1px solid #cbd5e1;
      border-radius: 4px;
      padding: 0.5rem;
      background: #fff;
      cursor: pointer;
      user-select: none;
    }
    details.dropdown > summary::-webkit-details-marker {
      display: none;
    }
    details.dropdown[open] > summary {
      outline: 2px solid rgba(37, 99, 235, 0.35);
      outline-offset: 2px;
    }
    .dropdown-panel {
      position: absolute;
      top: calc(100% + 6px);
      left: 0;
      right: 0;
      z-index: 30;
      background: #fff;
      border: 1px solid #cbd5e1;
      border-radius: 8px;
      box-shadow: 0 14px 30px rgba(15, 23, 42, 0.18);
      padding: 0.75rem;
      max-height: 320px;
      overflow: auto;
    }
    .node-availability-list {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }
    .node-availability-item {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 0.75rem;
      padding: 0.35rem 0.4rem;
      border-radius: 6px;
    }
    .node-availability-item:hover {
      background: #f1f5f9;
    }
    .node-availability-visible {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      margin: 0;
      font-weight: 600;
      color: #1f2937;
    }
    .node-availability-visible input[type="checkbox"] {
      width: auto;
      margin: 0;
    }
    .node-availability-fold {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      font-size: 0.85rem;
      color: #334155;
      user-select: none;
      white-space: nowrap;
    }
    .node-availability-fold input[type="checkbox"] {
      width: auto;
      margin: 0;
    }
    button {
      background: #2a9d8f;
      color: #fff;
      border: none;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    button:hover {
      background: #1f7f76;
    }
    button.button-secondary {
      background: #e2e8f0;
      color: #0f172a;
      border: 1px solid #94a3b8;
    }
    button.button-secondary:hover {
      background: #b6c2d1;
    }
    .form-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 1rem;
      margin-bottom: 1rem;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.95rem;
    }
    th, td {
      border-bottom: 1px solid #cbd5e1;
      padding: 0.6rem;
      text-align: left;
    }
    th {
      background: #e2e8f0;
    }
    .availability-legend {
      display: flex;
      gap: 1rem;
      font-size: 0.9rem;
      color: #334155;
    }
    .status {
      padding: 0.75rem 1rem;
      border-radius: 6px;
      font-size: 0.95rem;
      margin-bottom: 1rem;
      opacity: 1;
      transition: opacity 0.7s ease;
    }
    .status.hidden {
      opacity: 0;
    }
    .status.success {
      background: #dcfce7;
      color: #166534;
    }
    .status.error {
      background: #fee2e2;
      color: #991b1b;
    }
    .status.info {
      background: #e0f2fe;
      color: #0c4a6e;
    }
    .availability-table {
      table-layout: auto;
      width: max-content;
      min-width: 100%;
      border-collapse: collapse;
    }
    .availability-table th:first-child, .availability-table td:first-child {
      width: 180px;
      text-align: left;
      background: #f1f5f9;
      z-index: 2;
      position: sticky;
      left: 0;
    }
    .availability-table th {
      text-align: center;
      font-size: 0.9rem;
      padding: 0.4rem;
      background: #cbd5e1;
    }
    .gpu-label-cell {
      font-weight: 600;
      font-size: 0.9rem;
      background: #f1f5f9;
    }
    .availability-table th:not(:first-child) {
      min-width: 96px;
    }
    .availability-table td.grid-cell {
      min-width: 96px;
    }
    #availability-container {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .availability-node[data-collapsed="true"] tbody {
      display: none;
    }
    .availability-node[data-collapsed="true"] .availability-table-title {
      margin-bottom: 0;
      opacity: 0.95;
    }
    .availability-node-toggle {
      width: auto;
      background: transparent;
      border: none;
      padding: 0.2rem;
      margin: -0.2rem 0.3rem -0.2rem -0.2rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font: inherit;
      color: inherit;
      gap: 0.5rem;
    }
    .availability-node-toggle:hover {
      background: rgba(148, 163, 184, 0.2);
      border-radius: 4px;
    }
    .availability-node-caret {
      width: 0;
      height: 0;
      border-top: 5px solid transparent;
      border-bottom: 5px solid transparent;
      border-left: 6px solid #334155;
      transform: rotate(90deg);
      transition: transform 0.15s ease;
    }
    .availability-node[data-collapsed="true"] .availability-node-caret {
      transform: rotate(0deg);
    }
    .availability-table-wrapper {
      margin: 0;
    }
    .availability-table-title {
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: #1f2937;
    }
    .grid-cell {
      text-align: center;
      font-size: 0.85rem;
      padding: 0.45rem 0.3rem;
      min-height: 48px;
      border-bottom: 1px solid #cbd5e1;
    }
    .grid-cell .cell-user {
      font-weight: 600;
    }
    .grid-cell .cell-detail {
      font-size: 0.72rem;
      margin-top: 0.15rem;
      display: block;
    }
    .cell-free {
      background: #f8fafc;
      color: #334155;
    }
    .cell-booked-high {
      background: #fee2e2;
      color: #b91c1c;
    }
    .cell-booked-medium {
      background: #fef3c7;
      color: #b45309;
    }
    .cell-booked-low {
      background: #dcfce7;
      color: #15803d;
    }
    .cell-current-day {
      background: #f1f5f9 !important;
    }
    .cell-selected {
      outline: 2px solid #2563eb;
      outline-offset: -2px;
      background: #dbeafe !important;
      color: #1e3a8a !important;
    }
    .priority-legend {
      display: flex;
      gap: 0.75rem;
      font-size: 0.85rem;
      color: #475569;
    }
    #help-modal {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.55);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 1.25rem;
      z-index: 50;
    }
    #help-modal[aria-hidden="false"] {
      display: flex;
    }
    .modal-card {
      width: min(760px, 95vw);
      max-height: min(80vh, 720px);
      overflow: auto;
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 24px 60px rgba(15, 23, 42, 0.35);
      border: 1px solid rgba(148, 163, 184, 0.55);
    }
    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      padding: 1rem 1.25rem;
      border-bottom: 1px solid #e2e8f0;
      position: sticky;
      top: 0;
      background: #fff;
      z-index: 1;
    }
    .modal-header h3 {
      margin: 0;
      font-size: 1.1rem;
      color: #0f172a;
    }
    .modal-body {
      padding: 1rem 1.25rem 1.25rem;
      color: #0f172a;
      font-size: 0.95rem;
      line-height: 1.45;
    }
    .modal-body h4 {
      margin: 1rem 0 0.35rem;
      font-size: 1rem;
      color: #0f172a;
    }
    .modal-body ul {
      margin: 0.25rem 0 0.75rem 1.25rem;
      padding: 0;
    }
    .modal-close {
      width: auto;
      padding: 0.35rem 0.65rem;
      font-size: 0.9rem;
    }
    .legend-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
    }
    .legend-chip span {
      width: 12px;
      height: 12px;
      border-radius: 2px;
      display: inline-block;
    }
    .legend-high { background: #fee2e2; border: 1px solid #fca5a5; }
    .legend-medium { background: #fef3c7; border: 1px solid #fcd34d; }
    .legend-low { background: #dcfce7; border: 1px solid #86efac; }
    @media (max-width: 1200px) {
      .availability-table th:first-child,
      .availability-table td:first-child {
        width: 150px;
      }
      .availability-table th:not(:first-child),
      .availability-table td.grid-cell {
        min-width: 80px;
      }
      #availability-table th {
        font-size: 0.8rem;
        padding: 0.3rem;
      }
      .grid-cell {
        font-size: 0.78rem;
        min-height: 44px;
      }
      .grid-cell .cell-user {
        font-size: 0.82rem;
      }
      .grid-cell .cell-detail {
        font-size: 0.68rem;
      }
    }
    @media (max-width: 768px) {
      .form-row {
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      }
      .availability-table {
        font-size: 0.75rem;
      }
      .availability-table th:first-child,
      .availability-table td:first-child {
        width: 130px;
      }
      .availability-table th:not(:first-child),
      .availability-table td.grid-cell {
        min-width: 64px;
      }
      #availability-table th:not(:first-child) {
        writing-mode: vertical-rl;
        transform: rotate(180deg);
        padding: 0.4rem 0.2rem;
      }
      .grid-cell {
        font-size: 0.7rem;
        padding: 0.35rem 0.2rem;
        min-height: 40px;
      }
      .grid-cell .cell-user {
        font-size: 0.74rem;
      }
      .grid-cell .cell-detail {
        font-size: 0.62rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-row">
      <div class="header-text">
        <h1>ProcPlan Scheduler</h1>
        <p>Plan GPU usage on shared nodes.</p>
      </div>
      <button type="button" id="help-button">Help</button>
    </div>
  </header>
  <main>
    <section id="controls">
      <h2>Availability</h2>
      <div class="form-row">
        <div>
          <label>Nodes</label>
          <details id="node-availability-dropdown" class="dropdown">
            <summary id="node-availability-summary">All nodes</summary>
            <div class="dropdown-panel">
              <div id="node-availability-list" class="node-availability-list"></div>
            </div>
          </details>
        </div>
        <div>
          <label for="date-input">Day</label>
          <input type="date" id="date-input">
        </div>
        <div>
          <label>&nbsp;</label>
          <button id="refresh-button">Refresh Availability</button>
        </div>
      </div>
      <div class="priority-legend">
        <span class="legend-chip"><span class="legend-high"></span>High priority</span>
        <span class="legend-chip"><span class="legend-medium"></span>Medium priority</span>
        <span class="legend-chip"><span class="legend-low"></span>Low priority</span>
      </div>
      <div id="booking-panel">
        <h3>Create Booking</h3>
        <form id="booking-form">
          <div class="form-row">
            <div>
              <label for="user-label">Initials / Alias</label>
              <input id="user-label" name="userLabel" required maxlength="12" placeholder="ABC" autocomplete="nickname">
            </div>
        <div>
          <label for="priority">Priority</label>
          <select id="priority" name="priority">
            <option value="high">High – critical</option>
            <option value="medium" selected>Medium – important</option>
            <option value="low">Low – best effort</option>
          </select>
        </div>
      </div>
      <div class="form-row">
        <div>
          <label for="availability-start">Availability start</label>
          <input type="date" id="availability-start" name="availabilityStart" autocomplete="off">
        </div>
        <div>
          <label for="availability-end">Availability end</label>
          <input type="date" id="availability-end" name="availabilityEnd" autocomplete="off">
        </div>
      </div>
      <div>
        <p>Select free day cells in the grid (drag horizontally or vertically) to choose GPU(s) and duration.</p>
      </div>
      <div style="margin-top: 1rem;">
        <button type="submit">Book Slot</button>
          </div>
        </form>
      </div>
      <div id="manage-booking-panel" hidden>
        <h3>Manage Bookings</h3>
        <p id="manage-booking-summary"></p>
        <ul id="manage-booking-list"></ul>
        <button type="button" id="manage-booking-close">Hide booking manager</button>
      </div>
    </section>

    <section id="status-panel" hidden>
      <div id="status-message" class="status info"></div>
    </section>

    <section id="availability-section">
      <div id="availability-container"></div>
    </section>
  </main>

  <div id="help-modal" aria-hidden="true" role="dialog" aria-modal="true" aria-labelledby="help-modal-title">
    <div class="modal-card" role="document">
      <div class="modal-header">
        <h3 id="help-modal-title">How to use ProcPlan</h3>
        <button type="button" id="help-close" class="button-secondary modal-close">Close</button>
      </div>
      <div class="modal-body">
        <h4>Book a single GPU</h4>
        <ul>
          <li>Enter your initials/alias and pick a priority.</li>
          <li>In the grid, click and drag across <strong>Free</strong> cells on one GPU row to select a date range.</li>
          <li>Confirm the range in <strong>Availability start/end</strong>, then click <strong>Book Slot</strong>.</li>
        </ul>

        <h4>Book multiple GPUs</h4>
        <ul>
          <li>Drag across multiple GPU rows (vertical) and multiple days (horizontal) to select a rectangle of free cells.</li>
          <li>The booking will apply to all selected GPU rows for the selected date range.</li>
        </ul>

        <h4>Inspect or cancel a booking</h4>
        <ul>
          <li>Click a non-free (booked/partial) cell to open <strong>Manage Bookings</strong>.</li>
          <li>Use <strong>Cancel booking</strong> to remove a reservation.</li>
        </ul>

        <h4>Node controls</h4>
        <ul>
          <li>Use the <strong>Nodes</strong> dropdown to show/hide nodes and fold/unfold their tables.</li>
          <li>Folded nodes keep the header visible while hiding GPU rows.</li>
        </ul>

        <h4>Other controls</h4>
        <ul>
          <li><strong>Day</strong> chooses the year to load (any date in that year works).</li>
          <li><strong>Refresh Availability</strong> reloads from the server.</li>
          <li>Press <strong>Esc</strong> to close this help and dismiss open dropdowns.</li>
        </ul>
      </div>
    </div>
  </div>

  <script>
    const helpButton = document.getElementById('help-button');
    const helpModal = document.getElementById('help-modal');
    const helpClose = document.getElementById('help-close');
    const nodeAvailabilityDropdown = document.getElementById('node-availability-dropdown');
    const nodeAvailabilitySummary = document.getElementById('node-availability-summary');
    const nodeAvailabilityList = document.getElementById('node-availability-list');
    const dateInput = document.getElementById('date-input');
    const refreshButton = document.getElementById('refresh-button');
    const availabilityContainer = document.getElementById('availability-container');
    const statusPanel = document.getElementById('status-panel');
    const statusMessage = document.getElementById('status-message');
    const bookingForm = document.getElementById('booking-form');
    const availabilityStartInput = document.getElementById('availability-start');
    const availabilityEndInput = document.getElementById('availability-end');
    const userLabelInput = document.getElementById('user-label');
    const managePanel = document.getElementById('manage-booking-panel');
    const manageSummary = document.getElementById('manage-booking-summary');
    const manageList = document.getElementById('manage-booking-list');
    const manageCloseButton = document.getElementById('manage-booking-close');
    const priorityLabels = {
      high: { text: 'High', cell: 'cell-booked-high' },
      medium: { text: 'Medium', cell: 'cell-booked-medium' },
      low: { text: 'Low', cell: 'cell-booked-low' }
    };
    const MONTH_NAMES = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    const USER_LABEL_COOKIE = 'procplan_user_label';
    const COLLAPSED_NODES_STORAGE_KEY = 'procplan_collapsed_nodes_v1';
    const VISIBLE_NODES_STORAGE_KEY = 'procplan_visible_nodes_v1';

    let nodesCache = [];
    let currentGridDays = [];
    let selectionState = {
      active: false,
      table: null,
      baseRow: null,
      baseCol: null,
      startRow: null,
      endRow: null,
      startCol: null,
      endCol: null,
    };
    let selectedCellElements = [];
    let pendingSelection = null;

    let statusFadeTimer = null;

    function openHelpModal() {
      if (!helpModal) {
        return;
      }
      helpModal.setAttribute('aria-hidden', 'false');
      if (helpClose) {
        helpClose.focus();
      }
    }

    function closeHelpModal() {
      if (!helpModal) {
        return;
      }
      helpModal.setAttribute('aria-hidden', 'true');
      if (helpButton) {
        helpButton.focus();
      }
    }

    function loadCollapsedNodes() {
      try {
        const raw = localStorage.getItem(COLLAPSED_NODES_STORAGE_KEY);
        if (!raw) {
          return new Set();
        }
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) {
          return new Set();
        }
        return new Set(parsed.filter((id) => typeof id === 'string' && id.length > 0));
      } catch {
        return new Set();
      }
    }

    function saveCollapsedNodes(collapsed) {
      try {
        localStorage.setItem(COLLAPSED_NODES_STORAGE_KEY, JSON.stringify(Array.from(collapsed)));
      } catch {
        // ignore
      }
    }

    function setNodeCollapsed(nodeId, collapsed) {
      if (!nodeId) {
        return;
      }
      const collapsedNodes = loadCollapsedNodes();
      if (collapsed) {
        collapsedNodes.add(nodeId);
      } else {
        collapsedNodes.delete(nodeId);
      }
      saveCollapsedNodes(collapsedNodes);
      const nodeEl = availabilityContainer.querySelector(`.availability-node[data-node-id="${CSS.escape(nodeId)}"]`);
      if (nodeEl) {
        nodeEl.dataset.collapsed = collapsed ? 'true' : 'false';
      }
      renderNodeAvailabilityDropdown();
    }

    function loadVisibleNodes() {
      try {
        const raw = localStorage.getItem(VISIBLE_NODES_STORAGE_KEY);
        if (!raw) {
          return null;
        }
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) {
          return null;
        }
        return new Set(parsed.filter((id) => typeof id === 'string' && id.length > 0));
      } catch {
        return null;
      }
    }

    function saveVisibleNodes(visible) {
      try {
        localStorage.setItem(VISIBLE_NODES_STORAGE_KEY, JSON.stringify(Array.from(visible)));
      } catch {
        // ignore
      }
    }

    function getVisibleNodeIds() {
      const allIds = nodesCache.map((node) => node?.id).filter((id) => id);
      const stored = loadVisibleNodes();
      if (!stored) {
        return new Set(allIds);
      }
      const visible = new Set();
      allIds.forEach((id) => {
        if (stored.has(id)) {
          visible.add(id);
        }
      });
      return visible;
    }

    function updateNodeAvailabilitySummary(visible, collapsed) {
      if (!nodeAvailabilitySummary) {
        return;
      }
      const total = nodesCache.length;
      const visibleCount = visible.size;
      const collapsedCount = nodesCache.reduce((acc, node) => acc + (node?.id && collapsed.has(node.id) ? 1 : 0), 0);
      const base = visibleCount === 0
        ? 'No nodes'
        : visibleCount === total
          ? 'All nodes'
          : `${visibleCount}/${total} nodes`;
      nodeAvailabilitySummary.textContent = collapsedCount === 0 ? base : `${base} · Folded ${collapsedCount}`;
    }

    function renderNodeAvailabilityDropdown() {
      if (!nodeAvailabilityList) {
        return;
      }
      const visible = getVisibleNodeIds();
      const collapsed = loadCollapsedNodes();
      updateNodeAvailabilitySummary(visible, collapsed);

      nodeAvailabilityList.innerHTML = '';
      nodesCache.forEach((node) => {
        if (!node || !node.id) {
          return;
        }
        const row = document.createElement('div');
        row.className = 'node-availability-item';

        const mainLabel = document.createElement('label');
        mainLabel.className = 'node-availability-visible';
        const showCheckbox = document.createElement('input');
        showCheckbox.type = 'checkbox';
        showCheckbox.checked = visible.has(node.id);
        showCheckbox.addEventListener('change', () => {
          const nextVisible = getVisibleNodeIds();
          if (showCheckbox.checked) {
            nextVisible.add(node.id);
          } else {
            nextVisible.delete(node.id);
          }
          saveVisibleNodes(nextVisible);
          renderNodeAvailabilityDropdown();
          loadAvailability();
        });
        const nameWrap = document.createElement('span');
        nameWrap.textContent = `${node.name} (${node.gpu_count} GPUs)`;
        mainLabel.appendChild(showCheckbox);
        mainLabel.appendChild(nameWrap);
        row.appendChild(mainLabel);

        const foldLabel = document.createElement('label');
        foldLabel.className = 'node-availability-fold';
        const foldCheckbox = document.createElement('input');
        foldCheckbox.type = 'checkbox';
        foldCheckbox.checked = collapsed.has(node.id);
        foldCheckbox.addEventListener('change', () => {
          setNodeCollapsed(node.id, foldCheckbox.checked);
        });
        const foldText = document.createElement('span');
        foldText.textContent = 'Fold';
        foldLabel.appendChild(foldCheckbox);
        foldLabel.appendChild(foldText);
        row.appendChild(foldLabel);

        nodeAvailabilityList.appendChild(row);
      });
    }

    function clearAvailabilityFields() {
      if (availabilityStartInput) {
        availabilityStartInput.value = '';
      }
      if (availabilityEndInput) {
        availabilityEndInput.value = '';
      }
    }

    function setAvailabilityFields(startIso, endIso) {
      if (availabilityStartInput) {
        availabilityStartInput.value = (startIso || '').substring(0, 10);
      }
      if (availabilityEndInput) {
        availabilityEndInput.value = (endIso || '').substring(0, 10);
      }
    }

    function setUserLabelCookie(value) {
      const expires = new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toUTCString();
      const encoded = encodeURIComponent(value);
      document.cookie = `${USER_LABEL_COOKIE}=${encoded}; expires=${expires}; path=/`;
    }

    function getUserLabelCookie() {
      const cookies = document.cookie ? document.cookie.split(';') : [];
      for (const entry of cookies) {
        const [name, ...rest] = entry.trim().split('=');
        if (name === USER_LABEL_COOKIE) {
          return decodeURIComponent(rest.join('=') || '');
        }
      }
      return '';
    }

    if (userLabelInput) {
      const existing = getUserLabelCookie();
      if (existing) {
        userLabelInput.value = existing;
      }
    }

    function setStatus(message, tone = 'info') {
      if (statusFadeTimer) {
        clearTimeout(statusFadeTimer);
        statusFadeTimer = null;
      }
      statusMessage.textContent = message;
      statusMessage.className = `status ${tone}`;
      statusPanel.hidden = false;
      void statusMessage.offsetWidth;
      statusMessage.classList.remove('hidden');
      statusFadeTimer = setTimeout(() => {
        statusMessage.classList.add('hidden');
        setTimeout(() => {
          statusPanel.hidden = true;
          statusMessage.textContent = '';
          statusMessage.classList.remove('hidden');
        }, 700);
      }, tone === 'error' ? 6000 : 3500);
    }

    function clearStatus() {
      statusPanel.hidden = true;
      statusMessage.textContent = '';
      if (statusFadeTimer) {
        clearTimeout(statusFadeTimer);
        statusFadeTimer = null;
      }
    }

    function formatDateTimeLabel(isoString) {
      if (!isoString) {
        return '';
      }
      const date = new Date(isoString);
      if (Number.isNaN(date.getTime())) {
        return isoString;
      }
      return date.toLocaleString(undefined, {
        year: 'numeric',
        month: 'short',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false,
      });
    }

    function hideManagePanel() {
      if (managePanel) {
        managePanel.hidden = true;
        delete managePanel.dataset.nodeId;
        delete managePanel.dataset.gpuId;
        delete managePanel.dataset.dayKey;
      }
      if (manageSummary) {
        manageSummary.textContent = '';
      }
      if (manageList) {
        manageList.innerHTML = '';
      }
    }

    function clearSelectionDisplay() {
      if (!selectedCellElements.length) {
        return;
      }
      for (const cell of selectedCellElements) {
        if (cell && cell.classList) {
          cell.classList.remove('cell-selected');
        }
      }
      selectedCellElements = [];
    }

    function clearSelection() {
      clearSelectionDisplay();
      selectionState = {
        active: false,
        table: null,
        baseRow: null,
        baseCol: null,
        startRow: null,
        endRow: null,
        startCol: null,
        endCol: null,
      };
      pendingSelection = null;
      clearAvailabilityFields();
    }

    function isInPast(dayKey) {
      const today = new Date();
      const todayKey = today.toISOString().substring(0, 10);
      return dayKey < todayKey;
    }

    function getCellCoordinates(cell) {
      if (!cell) {
        return null;
      }
      const rowEl = cell.closest('tr');
      if (!rowEl) {
        return null;
      }
      const tbody = rowEl.parentElement;
      if (!tbody) {
        return null;
      }
      const table = tbody.closest('table');
      if (!table) {
        return null;
      }
      const rows = Array.from(tbody.querySelectorAll('tr'));
      const rowIndex = rows.indexOf(rowEl);
      const colIndex = parseInt(cell.dataset.colIndex || '', 10);
      if (rowIndex < 0 || Number.isNaN(colIndex)) {
        return null;
      }
      return { table, rows, rowIndex, colIndex };
    }

    function applySelection(table, startRow, endRow, startCol, endCol) {
      if (!table) {
        return false;
      }
      const tbody = table.tBodies[0];
      if (!tbody) {
        return false;
      }
      const rows = Array.from(tbody.querySelectorAll('tr'));
      if (rows.length === 0) {
        return false;
      }
      const firstRow = Math.min(startRow, endRow);
      const lastRow = Math.max(startRow, endRow);
      const firstCol = Math.min(startCol, endCol);
      const lastCol = Math.max(startCol, endCol);
      if (firstRow < 0 || lastRow >= rows.length) {
        return false;
      }
      const dayKeys = currentGridDays.map((day) => day.key);

      for (let rowIdx = firstRow; rowIdx <= lastRow; rowIdx += 1) {
        const row = rows[rowIdx];
        const rowCells = Array.from(row.querySelectorAll('td.grid-cell'));
        if (rowCells.length === 0) {
          return false;
        }
        for (let colIdx = firstCol; colIdx <= lastCol; colIdx += 1) {
          const cell = rowCells[colIdx];
          if (!cell || cell.dataset.status !== 'free') {
            return false;
          }
          const dayKey = dayKeys[colIdx];
          if (dayKey && isInPast(dayKey)) {
            return false;
          }
        }
      }

      clearSelectionDisplay();
      for (let rowIdx = firstRow; rowIdx <= lastRow; rowIdx += 1) {
        const row = rows[rowIdx];
        const rowCells = Array.from(row.querySelectorAll('td.grid-cell'));
        for (let colIdx = firstCol; colIdx <= lastCol; colIdx += 1) {
          const cell = rowCells[colIdx];
          cell.classList.add('cell-selected');
          selectedCellElements.push(cell);
        }
      }
      selectionState.startRow = firstRow;
      selectionState.endRow = lastRow;
      selectionState.startCol = firstCol;
      selectionState.endCol = lastCol;
      return true;
    }

    function beginSelection(cell) {
      if (!cell) {
        return;
      }
      const position = getCellCoordinates(cell);
      if (!position || cell.dataset.status !== 'free') {
        clearSelection();
        return;
      }
      const dayKey = currentGridDays[position.colIndex] ? currentGridDays[position.colIndex].key : null;
      if (dayKey && isInPast(dayKey)) {
        clearSelection();
        setStatus('Cannot book days in the past.', 'error');
        return;
      }
      clearSelection();
      selectionState.active = true;
      selectionState.table = position.table;
      selectionState.baseRow = position.rowIndex;
      selectionState.baseCol = position.colIndex;
      applySelection(selectionState.table, position.rowIndex, position.rowIndex, position.colIndex, position.colIndex);
    }

    function extendSelection(cell) {
      if (
        !selectionState.active ||
        !selectionState.table ||
        selectionState.baseRow === null ||
        selectionState.baseCol === null
      ) {
        return;
      }
      const position = getCellCoordinates(cell);
      if (!position || position.table !== selectionState.table) {
        return;
      }
      if (cell.dataset.status !== 'free') {
        return;
      }
      const dayKey = currentGridDays[position.colIndex] ? currentGridDays[position.colIndex].key : null;
      if (dayKey && isInPast(dayKey)) {
        return;
      }
      applySelection(
        selectionState.table,
        selectionState.baseRow,
        position.rowIndex,
        selectionState.baseCol,
        position.colIndex
      );
    }

    function finalizeSelection() {
      if (!selectionState.active) {
        return;
      }
      selectionState.active = false;
      if (
        selectionState.table &&
        selectionState.startRow !== null &&
        selectionState.endRow !== null &&
        selectionState.startCol !== null &&
        selectionState.endCol !== null
      ) {
        updateFormFromSelection();
      }
    }

    function updateFormFromSelection() {
      if (
        !selectionState.table ||
        selectionState.startRow === null ||
        selectionState.endRow === null ||
        selectionState.startCol === null ||
        selectionState.endCol === null
      ) {
        return;
      }
      const tbody = selectionState.table.tBodies[0];
      if (!tbody) {
        return;
      }
      const rows = Array.from(tbody.querySelectorAll('tr'));
      const startRow = Math.min(selectionState.startRow, selectionState.endRow);
      const endRow = Math.max(selectionState.startRow, selectionState.endRow);
      const startIdx = Math.min(selectionState.startCol, selectionState.endCol);
      const endIdx = Math.max(selectionState.startCol, selectionState.endCol);
      if (!currentGridDays[startIdx] || startRow < 0 || endRow >= rows.length) {
        return;
      }
      const slotCount = endIdx - startIdx + 1;
      const startIso = currentGridDays[startIdx].start;
      const durationHours = slotCount * 24;
      const endUtc = new Date(startIso);
      endUtc.setUTCDate(endUtc.getUTCDate() + slotCount - 1);
      const endIso = endUtc.toISOString();
      const gpuIds = rows
        .slice(startRow, endRow + 1)
        .map((row) => row.dataset.gpuId || '')
        .filter((id) => id);
      const uniqueGpuIds = Array.from(new Set(gpuIds));
      if (uniqueGpuIds.length === 0) {
        return;
      }
      const nodeId = rows[startRow]?.dataset.nodeId || '';

      if (dateInput) {
        dateInput.value = startIso.substring(0, 10);
      }
      pendingSelection = {
        startIso,
        durationHours,
        gpuIds: uniqueGpuIds,
        nodeId,
        startIdx,
        endIdx,
        startRow,
        endRow,
        endIso,
      };
      setAvailabilityFields(startIso, endIso);
      const dayLabel = slotCount === 1 ? 'day' : 'days';
      const gpuLabel = uniqueGpuIds.length === 1 ? uniqueGpuIds[0] : `${uniqueGpuIds.length} GPUs`;
      setStatus(`Prepared booking for ${slotCount} ${dayLabel} on ${gpuLabel}.`, 'info');
    }

    function applySelectionFromAvailabilityFields() {
      if (!availabilityStartInput || !availabilityEndInput) {
        return;
      }
      const startKey = availabilityStartInput.value;
      const endKey = availabilityEndInput.value;
      if (!startKey || !endKey) {
        return;
      }
      if (!selectionState.table) {
        setStatus('Select free cells in the grid before adjusting availability dates.', 'error');
        return;
      }
      const selectionStartRow = selectionState.startRow ?? selectionState.baseRow;
      const selectionEndRow = selectionState.endRow ?? selectionState.baseRow;
      if (selectionStartRow === null || selectionEndRow === null) {
        setStatus('Select GPU rows in the grid before adjusting dates.', 'error');
        return;
      }
      const startIdx = currentGridDays.findIndex((day) => day.key === startKey);
      const endIdx = currentGridDays.findIndex((day) => day.key === endKey);
      if (startIdx === -1 || endIdx === -1) {
        setStatus('Dates must be within the loaded availability grid. Update the Day filter and refresh if needed.', 'error');
        return;
      }
      const firstIdx = Math.min(startIdx, endIdx);
      const lastIdx = Math.max(startIdx, endIdx);
      const success = applySelection(
        selectionState.table,
        selectionStartRow,
        selectionEndRow,
        firstIdx,
        lastIdx
      );
      if (!success) {
        setStatus('Cannot update the selection to that range. Some days may be booked or in the past.', 'error');
        return;
      }
      selectionState.baseCol = firstIdx;
      selectionState.baseRow = selectionStartRow;
      updateFormFromSelection();
    }

    function scrollToCurrentDay(days) {
      const container = document.getElementById('availability-section');
      if (!container || !days || days.length === 0) {
        return;
      }
      let targetIndex = 0;
      const now = new Date();
      const todayKey = now.toISOString().substring(0, 10);
      const idx = days.findIndex((day) => day.key === todayKey);
      if (idx !== -1) {
        targetIndex = idx;
      }

      const firstTable = availabilityContainer.querySelector('.availability-table');
      if (!firstTable) {
        return;
      }
      const headerCells = firstTable.querySelectorAll('thead th');
      const firstDataHeader = headerCells[1];
      const targetHeader = headerCells[targetIndex + 1];
      if (!firstDataHeader || !targetHeader) {
        return;
      }
      const offset = targetHeader.offsetLeft - firstDataHeader.offsetLeft;
      const containerWidth = container.clientWidth;
      const scrollLeft = Math.max(offset, 0);
      container.scrollLeft = scrollLeft;
    }

    function formatHour(isoString) {
      const dt = new Date(isoString);
      return dt.toISOString().substring(11, 16);
    }

    function formatDayLabelFromKey(dayKey) {
      const parts = dayKey.split('-');
      if (parts.length !== 3) {
        return dayKey;
      }
      const monthIdx = Math.max(0, Math.min(11, parseInt(parts[1], 10) - 1));
      const dayNum = parseInt(parts[2], 10);
      const month = MONTH_NAMES[monthIdx] || parts[1];
      return `${month} ${dayNum}`;
    }

    function ensureDateValue() {
      if (!dateInput.value) {
        const now = new Date();
        const year = now.getUTCFullYear();
        const month = String(now.getUTCMonth() + 1).padStart(2, '0');
        const day = String(now.getUTCDate()).padStart(2, '0');
        dateInput.value = `${year}-${month}-${day}`;
      }
    }

    async function loadNodes() {
      try {
        const response = await fetch('/api/nodes');
        if (!response.ok) {
          throw new Error(`Failed to load nodes (${response.status})`);
        }
        const data = await response.json();
        nodesCache = data.nodes || [];
        renderNodeAvailabilityDropdown();
        ensureDateValue();
        if (nodesCache.length > 0) {
          await loadAvailability();
        } else {
          setStatus('No nodes are configured. Check the server configuration file.', 'error');
        }
      } catch (err) {
        setStatus(err.message, 'error');
      }
    }

    function buildIntervalIsoStrings(dateStr) {
      const date = new Date(dateStr);
      const year = Number.isNaN(date.getTime()) ? new Date().getUTCFullYear() : date.getUTCFullYear();
      const start = new Date(Date.UTC(year, 0, 1, 0, 0, 0));
      const end = new Date(Date.UTC(year + 1, 0, 1, 0, 0, 0));
      return {
        startIso: start.toISOString(),
        endIso: end.toISOString()
      };
    }

    async function loadAvailability() {
      ensureDateValue();
      clearSelection();
      hideManagePanel();
      const { startIso, endIso } = buildIntervalIsoStrings(dateInput.value);
      try {
        let datasets = [];
        const visible = getVisibleNodeIds();
        if (visible.size === 0) {
          availabilityContainer.innerHTML = '';
          currentGridDays = [];
          setStatus('No nodes selected. Use Nodes to show one or more nodes.', 'info');
          return;
        }
        const nodesToLoad = nodesCache.filter((node) => node && node.id && visible.has(node.id));
        datasets = await Promise.all(
          nodesToLoad.map(async (node) => {
            const resp = await fetch(`/api/availability?node_id=${encodeURIComponent(node.id)}&start=${encodeURIComponent(startIso)}&end=${encodeURIComponent(endIso)}&granularity=day`);
            if (!resp.ok) {
              throw new Error(`Failed to load availability for ${node.name} (${resp.status})`);
            }
            const json = await resp.json();
            return { node, data: json };
          })
        );
        renderAvailability(datasets);
        clearStatus();
      } catch (err) {
        availabilityContainer.innerHTML = '';
        clearSelection();
        setStatus(err.message, 'error');
      }
    }

    function renderAvailability(datasets) {
      clearSelection();
      hideManagePanel();
      availabilityContainer.innerHTML = '';

      const validData = datasets.filter((entry) => entry && entry.data && entry.data.grid);
      if (validData.length === 0) {
        currentGridDays = [];
        return;
      }

      const firstGrid = validData[0].data.grid || {};
      const candidateDays = Array.isArray(firstGrid.days) ? firstGrid.days : [];
      const hasDayAggregation = candidateDays.length > 0;
      const usingDayAggregation = hasDayAggregation && validData.every((entry) => {
        const grid = entry?.data?.grid;
        return grid && Array.isArray(grid.days) && grid.days.length === candidateDays.length;
      });

      let dayList = [];
      if (usingDayAggregation) {
        dayList = candidateDays.map((day, index) => ({
          key: day.key,
          start: day.start,
          end: day.end,
          slotIndex: index,
        }));
      } else {
        const hours = Array.isArray(firstGrid.hours) ? firstGrid.hours : [];
        const dayMap = new Map();
        hours.forEach((hour, index) => {
          if (!hour || !hour.start) {
            return;
          }
          const dayKey = hour.start.substring(0, 10);
          let dayEntry = dayMap.get(dayKey);
          if (!dayEntry) {
            dayEntry = { key: dayKey, start: hour.start, indices: [] };
            dayMap.set(dayKey, dayEntry);
            dayList.push(dayEntry);
          }
          dayEntry.indices.push(index);
        });
      }

      currentGridDays = dayList.map((day) => ({ key: day.key, start: day.start }));

      const todayKey = new Date().toISOString().substring(0, 10);
      const priorityRank = { low: 0, medium: 1, high: 2 };

      const collapsedNodes = loadCollapsedNodes();

      validData.forEach(({ node, data }) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'availability-table-wrapper';
        wrapper.classList.add('availability-node');
        wrapper.dataset.nodeId = node.id;
        wrapper.dataset.collapsed = collapsedNodes.has(node.id) ? 'true' : 'false';

        const title = document.createElement('div');
        title.className = 'availability-table-title';
        const toggle = document.createElement('button');
        toggle.type = 'button';
        toggle.className = 'availability-node-toggle';
        toggle.title = 'Collapse/expand node';
        toggle.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          const next = wrapper.dataset.collapsed !== 'true';
          wrapper.dataset.collapsed = next ? 'true' : 'false';
          setNodeCollapsed(node.id, next);
        });
        const caret = document.createElement('span');
        caret.className = 'availability-node-caret';
        caret.setAttribute('aria-hidden', 'true');
        toggle.appendChild(caret);
        const titleText = document.createElement('span');
        titleText.textContent = `${node.name} (${node.id})`;
        toggle.appendChild(titleText);
        title.appendChild(toggle);
        wrapper.appendChild(title);

        const table = document.createElement('table');
        table.className = 'availability-table';

        const thead = document.createElement('thead');
        const headRow = document.createElement('tr');
        headRow.className = 'availability-days-row';
        const headFirst = document.createElement('th');
        headFirst.textContent = 'GPU (kind)';
        headRow.appendChild(headFirst);
        dayList.forEach((day, index) => {
          const th = document.createElement('th');
          th.textContent = formatDayLabelFromKey(day.key);
          th.dataset.dayKey = day.key;
          th.dataset.colIndex = String(index);
          if (day.key === todayKey) {
            th.classList.add('cell-current-day');
          }
          headRow.appendChild(th);
        });
        thead.appendChild(headRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        const rows = data.grid.rows || [];
        for (const row of rows) {
          const tr = document.createElement('tr');
          const labelCell = document.createElement('td');
          labelCell.className = 'gpu-label-cell';
          const gpu = row.gpu || {};
          tr.dataset.gpuId = gpu.id || '';
          tr.dataset.nodeId = node.id;
          const kind = gpu.kind ? ` (${gpu.kind})` : '';
          labelCell.textContent = `${gpu.id || 'GPU'}${kind}`;
          tr.appendChild(labelCell);

          const slots = row.hour_slots || [];
          const daySlots = row.day_slots || [];
          let datasetDayIndices = [];
          if (!usingDayAggregation) {
            const gridHours = Array.isArray(data.grid.hours) ? data.grid.hours : [];
            const dayIndexMap = new Map();
            gridHours.forEach((hour, hourIdx) => {
              if (!hour || !hour.start) {
                return;
              }
              const dayKey = hour.start.substring(0, 10);
              let bucket = dayIndexMap.get(dayKey);
              if (!bucket) {
                bucket = [];
                dayIndexMap.set(dayKey, bucket);
              }
              bucket.push(hourIdx);
            });
            datasetDayIndices = dayList.map((day) => dayIndexMap.get(day.key) || []);
          }

          dayList.forEach((day, index) => {
            const td = document.createElement('td');
            td.classList.add('grid-cell');
            td.dataset.colIndex = String(index);
            td.dataset.gpuId = gpu.id || '';
            td.dataset.nodeId = node.id;
            td.dataset.dayStart = day.start;

            if (usingDayAggregation) {
              const slotIndex = day.slotIndex ?? index;
              const slot = daySlots[slotIndex] || null;
              const bookedHours = slot ? Number(slot.booked_hours || 0) : 0;
              const totalHours = slot ? Number(slot.total_hours || 24) : 24;

              if (!slot || bookedHours === 0) {
                td.classList.add('cell-free');
                td.dataset.status = 'free';
                delete td.dataset.bookings;
                td.textContent = 'Free';
                td.title = 'Free';
              } else {
                const priorityKey = (slot.priority || 'medium').toLowerCase();
                const priorityInfo = priorityLabels[priorityKey] || priorityLabels.medium;
                td.classList.add(priorityInfo.cell || 'cell-booked-medium');
                td.dataset.status = slot.status || (bookedHours === totalHours ? 'occupied' : 'partial');
                const bookings = Array.isArray(slot.bookings) ? slot.bookings : [];
                if (bookings.length > 0) {
                  td.dataset.bookings = JSON.stringify(bookings);
                } else {
                  delete td.dataset.bookings;
                }

                let representativeBooking = null;
                let bestRank = -1;
                bookings.forEach((booking) => {
                  const priority = (booking.priority || 'medium').toLowerCase();
                  const rank = priorityRank[priority] ?? 1;
                  if (rank > bestRank) {
                    bestRank = rank;
                    representativeBooking = booking;
                  }
                });

                const userSpan = document.createElement('span');
                userSpan.className = 'cell-user';
                const label = representativeBooking ? (representativeBooking.user_label || 'Booked') : (bookedHours === totalHours ? 'Booked' : 'Partial');
                userSpan.textContent = label;
                const detailSpan = document.createElement('span');
                detailSpan.className = 'cell-detail';
                detailSpan.textContent = `${bookedHours}h reserved`;
                td.appendChild(userSpan);
                td.appendChild(detailSpan);

                if (bookings.length > 0) {
                  td.title = bookings
                    .map((booking) => `#${booking.id} ${booking.user_label || ''} (${booking.priority || 'medium'})`)
                    .join('\n');
                } else {
                  td.title = `${label} (${priorityKey})`;
                }
              }
            } else {
              let bookedHours = 0;
              let bestPriority = 'medium';
              let bestRank = -1;
              let representativeBooking = null;
              const bookingMap = new Map();

              const hourIndices = datasetDayIndices[index] || [];
              hourIndices.forEach((hourIdx) => {
                const slot = slots[hourIdx];
                if (slot && slot.status === 'booked' && slot.booking) {
                  bookedHours += 1;
                  const booking = slot.booking;
                  const priorityKey = (booking.priority || 'medium').toLowerCase();
                  const rank = priorityRank[priorityKey] ?? 1;
                  if (rank > bestRank) {
                    bestPriority = priorityKey;
                    bestRank = rank;
                    representativeBooking = booking;
                  }
                  const existing = bookingMap.get(booking.id);
                  if (!existing) {
                    bookingMap.set(booking.id, {
                      id: booking.id,
                      label: booking.user_label,
                      user_label: booking.user_label,
                      priority: priorityKey,
                      start: booking.start,
                      end: booking.end,
                      hours: 1,
                      node_id: node.id,
                      gpu_id: gpu.id,
                    });
                  } else {
                    existing.hours += 1;
                    if (booking.start < existing.start) {
                      existing.start = booking.start;
                    }
                    if (booking.end > existing.end) {
                      existing.end = booking.end;
                    }
                  }
                }
              });

              const bookingSummaries = Array.from(bookingMap.values());
              const totalHours = hourIndices.length || 24;
              if (bookedHours === 0) {
                td.classList.add('cell-free');
                td.dataset.status = 'free';
                delete td.dataset.bookings;
                td.textContent = 'Free';
                td.title = 'Free';
              } else {
                const priorityInfo = priorityLabels[bestPriority] || priorityLabels.medium;
                td.classList.add(priorityInfo.cell || 'cell-booked-medium');
                td.dataset.status = bookedHours === totalHours ? 'occupied' : 'partial';
                td.dataset.bookings = JSON.stringify(bookingSummaries);
                const userSpan = document.createElement('span');
                userSpan.className = 'cell-user';
                const label = representativeBooking ? representativeBooking.user_label : bookedHours === totalHours ? 'Booked' : 'Partial';
                userSpan.textContent = label;
                const detailSpan = document.createElement('span');
                detailSpan.className = 'cell-detail';
                detailSpan.textContent = `${bookedHours}h reserved`;
                td.appendChild(userSpan);
                td.appendChild(detailSpan);
                if (bookingSummaries.length > 0) {
                  td.title = bookingSummaries
                    .map((summary) => `#${summary.id} ${summary.label || summary.user_label || ''} (${summary.priority || 'medium'})`)
                    .join('\n');
                } else {
                  td.title = `${label} (${bestPriority})`;
                }
              }
            }

            if (day.key === todayKey) {
              td.classList.add('cell-current-day');
            }

            tr.appendChild(td);
          });

          tbody.appendChild(tr);
        }

        table.appendChild(tbody);
        wrapper.appendChild(table);
        availabilityContainer.appendChild(wrapper);
      });

      scrollToCurrentDay(currentGridDays);
    }

    function showBookingManagement(cell) {
      if (!managePanel || !manageList || !manageSummary) {
        return;
      }
      const bookingsRaw = cell.dataset.bookings;
      if (!bookingsRaw) {
        hideManagePanel();
        return;
      }
      let bookings;
      try {
        bookings = JSON.parse(bookingsRaw);
      } catch (err) {
        console.error('Failed to parse booking metadata', err);
        hideManagePanel();
        setStatus('Unable to inspect booking details.', 'error');
        return;
      }
      if (!Array.isArray(bookings) || bookings.length === 0) {
        hideManagePanel();
        return;
      }
      manageList.innerHTML = '';
      const colIndex = parseInt(cell.dataset.colIndex || '', 10);
      const dayKey = currentGridDays[colIndex] ? currentGridDays[colIndex].key : '';
      const gpuId = cell.dataset.gpuId || '';
      const nodeId = cell.dataset.nodeId || '';
      managePanel.dataset.nodeId = nodeId;
      managePanel.dataset.gpuId = gpuId;
      managePanel.dataset.dayKey = dayKey;

      const labels = [];
      if (nodeId) {
        labels.push(`Node ${nodeId}`);
      }
      if (gpuId) {
        labels.push(`GPU ${gpuId}`);
      }
      if (dayKey) {
        labels.push(formatDayLabelFromKey(dayKey));
      }
      manageSummary.textContent = labels.join(' · ') || 'Selected booking';

      bookings
        .slice()
        .sort((a, b) => {
          const aStart = a.start || '';
          const bStart = b.start || '';
          return aStart.localeCompare(bStart);
        })
        .forEach((booking) => {
          const item = document.createElement('li');
          item.className = 'manage-booking-item';

          const details = document.createElement('div');
          details.className = 'manage-booking-details';

          const heading = document.createElement('div');
          heading.className = 'manage-booking-heading';
          const label = booking.label || booking.user_label || 'Booking';
          heading.textContent = `#${booking.id} · ${label}`;
          details.appendChild(heading);

          const timing = document.createElement('div');
          const startLabel = formatDateTimeLabel(booking.start);
          const endLabel = formatDateTimeLabel(booking.end);
          timing.textContent = `${startLabel} → ${endLabel}`;
          details.appendChild(timing);

          const hoursDetail = document.createElement('div');
          const hours = booking.hours || 0;
          const priorityRaw = booking.priority || 'medium';
          const priorityText = priorityRaw.charAt(0).toUpperCase() + priorityRaw.slice(1);
          hoursDetail.textContent = `${hours}h reserved · ${priorityText} priority`;
          details.appendChild(hoursDetail);

          item.appendChild(details);

          const cancelButton = document.createElement('button');
          cancelButton.type = 'button';
          cancelButton.textContent = 'Cancel booking';
          cancelButton.addEventListener('click', () => cancelBooking(booking));
          item.appendChild(cancelButton);

          manageList.appendChild(item);
        });

      managePanel.hidden = false;
    }

    async function cancelBooking(booking) {
      const bookingId = booking && booking.id;
      if (!bookingId) {
        setStatus('Missing booking identifier.', 'error');
        return;
      }
      const label = booking.label || booking.user_label || '';
      const confirmed = window.confirm(`Cancel booking #${bookingId}${label ? ` (${label})` : ''}?`);
      if (!confirmed) {
        return;
      }
      try {
        const response = await fetch(`/api/bookings/${bookingId}`, { method: 'DELETE' });
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          const message = errorData.error || `Failed to cancel booking (${response.status})`;
          throw new Error(message);
        }
        await response.json().catch(() => ({}));
        setStatus(`Booking #${bookingId} cancelled.`, 'success');
        hideManagePanel();
        await loadAvailability();
      } catch (err) {
        setStatus(err.message, 'error');
      }
    }

    function handleCellMouseDown(event) {
      if (event.button !== undefined && event.button !== 0) {
        return;
      }
      const cell = event.target.closest('td.grid-cell');
      if (!cell) {
        return;
      }
      const status = cell.dataset.status;
      if (status && status !== 'free') {
        clearSelection();
        showBookingManagement(cell);
        return;
      }
      event.preventDefault();
      hideManagePanel();
      beginSelection(cell);
    }

    function handleCellMouseOver(event) {
      if (!selectionState.active) {
        return;
      }
      const cell = event.target.closest('td.grid-cell');
      if (!cell) {
        return;
      }
      extendSelection(cell);
    }

    function handleDocumentMouseUp() {
      finalizeSelection();
    }

    availabilityContainer.addEventListener('mousedown', handleCellMouseDown);
    availabilityContainer.addEventListener('mouseover', handleCellMouseOver);
    document.addEventListener('mouseup', handleDocumentMouseUp);
    if (manageCloseButton) {
      manageCloseButton.addEventListener('click', (event) => {
        event.preventDefault();
        hideManagePanel();
      });
    }
    if (availabilityStartInput) {
      availabilityStartInput.addEventListener('change', applySelectionFromAvailabilityFields);
    }
    if (availabilityEndInput) {
      availabilityEndInput.addEventListener('change', applySelectionFromAvailabilityFields);
    }

    bookingForm.addEventListener('submit', async (event) => {
      event.preventDefault();
      if (!pendingSelection) {
        setStatus('Select at least one available day before booking.', 'error');
        return;
      }

      const userLabel = document.getElementById('user-label').value.trim();
      if (!userLabel) {
        setStatus('Enter your initials or alias.', 'error');
        return;
      }

      const priority = document.getElementById('priority').value;
      const nodeId = pendingSelection.nodeId;
      if (!nodeId || nodeId === 'all') {
        setStatus('Unable to determine target node from selection.', 'error');
        return;
      }
      const gpuIds = Array.isArray(pendingSelection.gpuIds) ? pendingSelection.gpuIds : [];
      if (gpuIds.length === 0) {
        setStatus('Unable to determine GPU selection from grid.', 'error');
        return;
      }

      const startUtc = new Date(pendingSelection.startIso);
      const endUtc = new Date(startUtc);
      endUtc.setUTCHours(endUtc.getUTCHours() + pendingSelection.durationHours);
      const now = new Date();
      const todayStart = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 0, 0, 0));
      if (startUtc < todayStart) {
        setStatus('Cannot create bookings in the past.', 'error');
        return;
      }

      const payload = {
        node_id: nodeId,
        user_label: userLabel,
        start: startUtc.toISOString(),
        end: endUtc.toISOString(),
        priority,
        gpu_ids: gpuIds,
      };

      try {
        const response = await fetch('/api/book', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(payload)
        });
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          const message = errorData.error || `Booking failed (${response.status})`;
          throw new Error(message);
        }
        const result = await response.json();
        const priorityInfo = priorityLabels[(result.priority || 'medium').toLowerCase()] || priorityLabels.medium;
        setStatus(`Booking confirmed (#${result.booking_id}) · ${priorityInfo.text} priority · ${result.gpu_ids.length} GPU(s).`, 'success');
        const savedLabel = userLabelInput ? userLabelInput.value.trim() : '';
        if (savedLabel) {
          setUserLabelCookie(savedLabel);
        }
        bookingForm.reset();
        if (userLabelInput) {
          userLabelInput.value = savedLabel;
        }
        pendingSelection = null;
        clearSelection();
        await loadAvailability();
      } catch (err) {
        setStatus(err.message, 'error');
      }
    });

    refreshButton.addEventListener('click', (event) => {
      event.preventDefault();
      loadAvailability();
    });

    dateInput.addEventListener('change', loadAvailability);

    document.addEventListener('click', (event) => {
      if (!nodeAvailabilityDropdown || !nodeAvailabilityDropdown.open) {
        return;
      }
      const target = event.target;
      if (target instanceof Node && nodeAvailabilityDropdown.contains(target)) {
        return;
      }
      nodeAvailabilityDropdown.open = false;
    });
    if (helpButton) {
      helpButton.addEventListener('click', (event) => {
        event.preventDefault();
        openHelpModal();
      });
    }
    if (helpClose) {
      helpClose.addEventListener('click', (event) => {
        event.preventDefault();
        closeHelpModal();
      });
    }
    if (helpModal) {
      helpModal.addEventListener('click', (event) => {
        if (event.target === helpModal) {
          closeHelpModal();
        }
      });
    }
    document.addEventListener('keydown', (event) => {
      if (event.key !== 'Escape') {
        return;
      }
      if (helpModal && helpModal.getAttribute('aria-hidden') === 'false') {
        closeHelpModal();
      }
      if (nodeAvailabilityDropdown && nodeAvailabilityDropdown.open) {
        nodeAvailabilityDropdown.open = false;
      }
    });

    if (nodeAvailabilityDropdown) {
      nodeAvailabilityDropdown.addEventListener('toggle', () => {
        if (nodeAvailabilityDropdown.open) {
          renderNodeAvailabilityDropdown();
        }
      });
    }

    loadNodes();
  </script>
</body>
</html>
